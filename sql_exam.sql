/*--------1---------

Создать таблицы:

EMPLOYEES (сотрудники). Столбцы:
id (число),
name (текст),
hire_date (дата),
gender (текст),
age (число),
salary (число),
manager_id (число),
department_id (число)

DEPARTMENTS (отделы). Столбцы:
id (число),
department (текст),
location_id (число)

LOCATIONS (местоположение). Столбцы:
id (число),
location (текст)

Ограничения целостности:

Исключить возможность вставки пустых значений в поле ID во всех таблицах.
Поле LOCATION_ID из таблицы DEPARTMENTS должно быть внешним ключом на поле ID из таблицы LOCATIONS
По завершению создания таблиц необходимо выполнить SQL скрипт для заполнения данных в таблицы


--------2---------
Создать уникальный индекс на поле ID из таблицы EMPLOYEES*/




create table EMPLOYEESi (
      id number generated by default as identity,
      name varchar2(100) null,
      hire_date date null,
      gender varchar2(100) null,
      age number null,
      salary number null,
      manager_id number null,
      departmaent_id number null
);

create unique index i_id on EMPLOYEESi(id); 

create table DEPARTMENTSi (
      id number generated by default as identity,
      department varchar2 (100) null,
      location_id number null,
      foreign key(location_id) references LOCATIONSi(id)
);

create table LOCATIONSi (
      id number primary key,
      location varchar2(100) null
);


/*--------3---------
Вывести всех сотрудников, у которых дата приема на работу либо пустая, либо позднее "01.01.2010", 
а также в имени или фамилии имеется буква "о".*/

select *
from EMPLOYEESi
where hire_date is null
      or hire_date > to_date('01.01.2010', 'dd-mm-yyyy')
      and name like ('%o%');

/*--------4---------
Вывести всех сотрудников-женщин младше 30 и сотрудников-мужчин в возрасте от 35 до 45 лет.*/

select *
from EMPLOYEESi
where (gender = 'F' and age < '30') 
       or (gender = 'M' and age between 35 and 45);

/*--------5---------
Отсортировать список сотрудников так, чтобы первым в списке был сотрудник с самими короткими именем и 
фамилией. 
При этом имя и фамилия всех сотрудников должны выводиться в верхнем регистре, а все сотрудники с именем 
Ivan должны быть переименованы в Viktor*/


select-- upper(name) as name,
       upper(replace(name,'Ivan','Viktor')) as up_name
      -- min(length(name)) min_length
from EMPLOYEESi
group by upper(replace(name,'Ivan','Viktor'))
order by min(length(name));

/*--------6---------
Вывести данные о сотрудниках таким образом, чтобы имя и фамилия сотрудника были в разных полях*/

select substr(name,instr(name, ' ',1)) as first_name,
       substr(name,1,instr(name, ' ',1)) as last_name
from EMPLOYEESi;

--------7---------
Вывести имя и год рождения каждого сотрудника

select substr(name,instr(name, ' ',1)) as first_name,
       hire_date
from employeesi;


--------8---------
Вывести данные обо всех сотрудниках и добавить названия отделов, в которых они работают

select employeesi.id,
       employeesi.name,
       employeesi.hire_date,
       employeesi.gender,
       employeesi.age,
       employeesi.salary,
       employeesi.manager_id,
       employeesi.departmaent_id,
       departmentsi.department
from employeesi
left join departmentsi
     on employeesi.departmaent_id = departmentsi.id;


--------9---------
Вывести данные только для тех сотрудников, которые числятся к каком-либо отделе. 
Если сотрудник не числится ни в одном отделе - данные не выводить

select *
from employeesi
where departmaent_id is not null;


--------10---------
Посчитать сколько сотрудников работает в каждом отделе

select departmentsi.department,
       count(employeesi.name) as count
from   employeesi
left join departmentsi
     on employeesi.departmaent_id = departmentsi.id
group by departmentsi.department
order by count; 


--------11---------
Вывести следующие данные: название отдела и среднюю зарплату сотрудника в нем. 
Средняя зарплата должны быть округлена до двух знаков после запятой. 
Отсортировать вывод в виде топа средних з/п, начиная с наибольшей
select round(avg(e.salary),2) as avg_salar,
       nvl(d.department, 'KRESLO') as name_department
from employeesi e
left join departmentsi d
     on e.departmaent_id = d.id
group by d.department
order by avg_salar desc;


--------12---------
Создать представление (View), которое выведет данные только о начальниках отделов. 
Начальник отдела не должен вычисляться по косвенным потенциально меняющимся признакам.
Нельзя отталкиваться от того, что сотрудник подчиняется Маслову, 
или что у их начальника пустой ID, или от зарплаты. 
Айдишники в нормальной ситуации могут меняться, а начальник у Маслова тоже есть.

/*create view boss_view as*/
select id, name, hire_date, gender, age, salary, manager_id, departmaent_id
from employeesi
where id in (select distinct manager_id
             from employeesi
             where manager_id is not null);

--------13---------
Вывести следующие данные: имя сотрудника и имя менеджера для него
select d.name,
       e.name as manager_name
from employeesi e
join employeesi d
     on e.id = d.manager_id;
where id = manager_id;
????????????? 


--------14---------
Вывести данные о том, в каком районе работает каждый сотрудник
select e.name,
       l.location
from employeesi e
left join departmentsi d
     on e.departmaent_id = d.id
left join locationsi l
     on d.location_id = l.id;


--------15---------
Добавить в таблицу LOCATIONS столбец CITY и заполнить его значением "Moscow"

UPDATE locationsi
   SET city = 'Moscow';
commit;

--------16---------
Посчитать, сколько сотрудников работает в северо-западном районе.

select count(e.name) as count_empl,
       l.location
from employeesi e
left join locationsi l
     on e.departmaent_id = l.id
where l.location = 'Northwest'
group by l.location;

--------17---------
Вывести названия отделов, у которых средний возраст сотрудников больше 30 лет

select round(avg(e.age),2) as avg_age,
       nvl(d.department, 'KRESLO') as name_department
from employeesi e
left join departmentsi d
     on e.departmaent_id = d.id
group by d.department
having avg(e.age) > 30;

--------18---------
Вывести информацию о самом молодом сотруднике (речь о возрасте)

select name, age
from employeesi
where age = (select min(age)
             from employeesi);

--------19---------
Вывести всю информацию о сотрудниках, но в поле GENDER вывести "Женский" вместо "F" и "Мужской" вместо "M"

select employeesi.id,
       employeesi.name,
       employeesi.hire_date,
       (CASE gender
       WHEN 'F' THEN 'Мужской'
       else 'Женский'
       END) as gender,
       employeesi.age,
       employeesi.salary,
       employeesi.manager_id,
       employeesi.departmaent_id
from employeesi;


select employeesi.id,
       employeesi.name,
       employeesi.hire_date,
       decode(gender, 'F', 'Женский',
                      'M', 'Мужской') as gender,
       employeesi.age,
       employeesi.salary,
       employeesi.manager_id,
       employeesi.departmaent_id
from employeesi;


select id,
       name,
       hire_date,
       replace(gender,'M','Мужской') as gender,
       age,
       salary,
       manager_id,
       departmaent_id
from employeesi
where replace(gender,'M','Мужской')!='F'
union
select id,
       name,
       hire_date,
       replace(gender,'F','Женский') as gender,
       age,
       salary,
       manager_id,
       departmaent_id
from employeesi
where replace(gender,'F','Женский')!='M';


--------20---------
Создать копию таблицы EMPLOYEES и назвать ее EMPLOYEES_BCKP. Изменить в EMPLOYEES_BCKP имя сотрудника 
"Dorofeeva Irina" на "Alieva Irina"

create table EMPLOYEES_BCKP as
       (select * 
        from employeesi);

update EMPLOYEES_BCKP
set
name = 'Alieva Irina'
where id = (select id
             from EMPLOYEES_BCKP
             where name = 'Dorofeeva Irina');

--------21---------
Отобразить структуру таблицы EMPLOYEES_BCKP

describe EMPLOYEES_BCKP;

--------22---------
Вставить в таблицу EMPLOYEES_BCKP дублирующую строку для сотрудника №11. Вывести только уникальные 
строки из таблицы EMPLOYEES_BCKP

insert into EMPLOYEES_BCKP
select * from EMPLOYEES_BCKP
where id = 11;


select distinct *
from EMPLOYEES_BCKP
order by id;


select id, name, hire_date, gender, age,salary, manager_id, departmaent_id
from EMPLOYEES_BCKP
group by id, name, hire_date, gender, age,salary, manager_id, departmaent_id
order by id;


select id , name, hire_date, gender, age,salary, manager_id, departmaent_id
from (
      select id , name, hire_date, gender, age,salary, manager_id, 
             departmaent_id, row_number() over(partition by name order by id) as h
      from EMPLOYEES_BCKP
      order by id
     )
where h = 1;

--------23---------
Написать SQL запрос, который сравнит таблицы EMPLOYEES и EMPLOYEES_BCKP. Если строка есть в обеих 
таблицах она должна выводиться только один раз.
У результирующих строк должен быть дополнительный атрибут, по которому можно понять таблицу-источник записи.

    select id, 
           name, 
           hire_date,
           gender,
           age,
           salary,
           manager_id,
           departmaent_id,
           'row_in_both_table' as or_id
        from (select id, 
                     name,
                     hire_date, 
                     gender, 
                     age,
                     salary, 
                     manager_id, 
                     departmaent_id
                from EMPLOYEES_BCKP
             intersect
               select id,
                      name,
                      hire_date, 
                      gender, 
                      age,
                      salary, 
                      manager_id, 
                      departmaent_id
                 from EMPLOYEESi)
union all
    select id, 
           name, 
           hire_date, 
           gender, 
           age,
           salary, 
           manager_id, 
           departmaent_id,
           'BKCP' as or_id
      from (select id, 
                  name, 
                  hire_date, 
                  gender, 
                  age,
                  salary, 
                  manager_id, 
                  departmaent_id 
             from EMPLOYEES_BCKP
                minus
           select id, 
                  name, 
                  hire_date, 
                  gender, 
                  age,
                  salary, 
                  manager_id, 
                  departmaent_id 
             from EMPLOYEESi)
union all
    select id, 
           name, 
           hire_date, 
           gender, 
           age,
           salary, 
           manager_id, 
           departmaent_id,
           'employ' as or_id 
           from (select id, 
                        name, 
                        hire_date, 
                        gender, 
                        age,
                        salary, 
                        manager_id, 
                        departmaent_id
                   from EMPLOYEESi
                minus
                 select id, 
                        name, 
                        hire_date, 
                        gender, 
                        age,
                        salary, 
                        manager_id, 
                        departmaent_id 
                   from EMPLOYEES_BCKP)
order by id;


with obwee AS
(
select id,
       name,
       hire_date,
       gender,
       age,
       salary,
       manager_id,
       departmaent_id,
       'row_in_both_table' as or_id 
from  (select id,
              name,
              hire_date,
              gender,
              age,salary,
              manager_id,
              departmaent_id --, 'nonoriginale' as or_id 
         from EMPLOYEES_BCKP 
    intersect 
       select id,
              name,
              hire_date,
              gender,
              age,
              salary,
              manager_id,
              departmaent_id--, 'originale' as or_id 
         from EMPLOYEESi) 
),
bckp AS
(
select id,
       name,
       hire_date,
       gender,
       age,salary,
       manager_id,
       departmaent_id,
       'BKCP' as or_id 
from(select id,
            name,
            hire_date,
            gender,
            age,
            salary,
            manager_id,
            departmaent_id
            -- 'nonoriginale' as or_id 
       from EMPLOYEES_BCKP 
    minus 
        select id,
               name,
               hire_date,
               gender,
               age,
               salary,
               manager_id,
               departmaent_id 
               -- 'originale' as or_id 
          from EMPLOYEESi) 
),
orig as 
(
select id,
       name,
       hire_date,
       gender,
       age,
       salary,
       manager_id,
       departmaent_id,
       'employ' as or_id  
  from (select id,
               name,
               hire_date,
               gender,
               age,salary,
               manager_id,
               departmaent_id -- 'originale' as or_id 
          from EMPLOYEESi 
            minus 
         select id,
                name,
                hire_date,
                gender,
                age,salary,
                manager_id,
                departmaent_id -- 'nonoriginale' as or_id 
           from EMPLOYEES_BCKP) 
),
norm_querry as 
(
select * from obwee
union all
select * from orig
union all
select * from bckp
)
select * from norm_querry;


--------24---------
Написать SQL запрос, который сравнит таблицы EMPLOYEES и EMPLOYEES_BCKP, таким образом, чтобы были 
показаны только уникальные для каждой из таблиц строки

    select id, 
           name, 
           hire_date, 
           gender, 
           age,
           salary, 
           manager_id, 
           departmaent_id,
           'BKCP' as or_id
      from (select id, 
                  name, 
                  hire_date, 
                  gender, 
                  age,
                  salary, 
                  manager_id, 
                  departmaent_id 
             from EMPLOYEES_BCKP
                minus
           select id, 
                  name, 
                  hire_date, 
                  gender, 
                  age,
                  salary, 
                  manager_id, 
                  departmaent_id 
             from EMPLOYEESi)
union all
    select id, 
           name, 
           hire_date, 
           gender, 
           age,
           salary, 
           manager_id, 
           departmaent_id,
           'employ' as or_id 
           from (select id, 
                        name, 
                        hire_date, 
                        gender, 
                        age,
                        salary, 
                        manager_id, 
                        departmaent_id
                   from EMPLOYEESi
                minus
                 select id, 
                        name, 
                        hire_date, 
                        gender, 
                        age,
                        salary, 
                        manager_id, 
                        departmaent_id 
                   from EMPLOYEES_BCKP);


--------25---------
Вставить в таблицу EMPLOYEES дублирующие строки для сотрудников №3 и №15 и написать запрос, 
удаляющий дублирующие записи из таблицы EMPLOYEES

insert into EMPLOYEESi
select e1.id ,e2.*
from (select 
               name, 
               hire_date,
               gender,
               age,
               salary,
               manager_id,
               departmaent_id
from           EMPLOYEESi
where id in (15)
group by name, 
       hire_date,
       gender,
       age,
       salary,
       manager_id,
       departmaent_id) e2
join (select  max(id)+1 as id from employeesi) e1
     on 1=1;
     
insert into EMPLOYEESi
select e1.id ,e2.*
from (select 
               name, 
               hire_date,
               gender,
               age,
               salary,
               manager_id,
               departmaent_id
from           EMPLOYEESi
where id in (3)
group by name, 
       hire_date,
       gender,
       age,
       salary,
       manager_id,
       departmaent_id) e2
join (select  max(id)+1 as id from employeesi) e1
     on 1=1; 
    

delete from EMPLOYEESi
where id in (
             select id
             from (select id,
                         name, 
                         hire_date,
                         gender,
                         age,
                         salary,
                         manager_id,
                         departmaent_id,
                         row_number() over(partition by name, hire_date order by id desc) as  rn
                    from EMPLOYEESi)
               where rn = 2
             );



--------26---------
Вывести список имен сотрудников для каждого отдела в одну строку, указанных через запятую

SELECT LISTAGG(name, ', ') WITHIN GROUP (ORDER BY id) "Spiski"
FROM employeesi;

--------27--------- (пропусти)
Написать SQL запрос, результатом которого был бы готовый код для удаления всех таблиц из схемы текущего пользователя. 
Таким образом, чтобы его можно было скопировать и выполнить. SQL запрос должен должен работать для любого количества таблиц в схеме пользователя

--------28---------
Написать SQL запрос, отображающий текущую дату локальной машины (дату сессии) и текущую дату 
БД (удалённого сервера)

select CURRENT_DATE from employeesi;

select CURRENT_TIMESTAMP from employeesi;

select LOCALTIMESTAMP from employeesi;

select SYSTIMESTAMP from employeesi;

---------29---------
Вывести в одном SQL запросе самого старого по возрасту сотрудника в каждом отделе
-------------------------

select e.name,
       e.age,
       nvl (e.departmaent_id, 'BOSS') as depart
from  employeesi e
join 
    (select nvl(departmaent_id, 'BOSS') as departmaent_id,
            max(age) as max_age
     from employeesi
     group by departmaent_id) m
on   nvl (e.departmaent_id, 'BOSS') = nvl (m.departmaent_id, 'BOSS') and e.age = m.max_age
order by e.id;

-----------------------------

with q as (select e.name,
       e.age,
       d.department,
       max(age) over(partition by departmaent_id) as max_age
from employeesi e
left join departmentsi d
             on e.departmaent_id = d.id
order by departmaent_id, age desc)
select name,
       age, 
       nvl(department, 'BOSS') as  department
from q where age = max_age;


---------30---------
-- Написать SQL запрос, который бы выводил данные о начальниках отделов и их подчиненных в виде древовидной иерархии, каждый следующий уровень иерархии должен отступать вправо на пробел от предыдущего

select level,
       lpad(' ',2 * level - 1) || name as name1
from employeesi
start with id = 1
connect by prior id = manager_id ;

---------31---------
-- Написать SQL запрос, отображающий сотрудников, у которых в фамилии присутствуют только гласные 'o', 'i' и 'e', а также длина имени не превышает 6 символов

with fl as
          (
           select substr(name,instr(name, ' ',1)) as first_name,
                  substr(name,1,instr(name, ' ',1)) as last_name,
                  length(substr(name,instr(name, ' ',1))) -1 as length_name
           from EMPLOYEESi      
          )
 select first_name,
        last_name
 from fl 
 where (length_name <= 6) and (
                               last_name like '%o%'
                               and last_name like '%i%'
                               and last_name like '%e%'
                               );

